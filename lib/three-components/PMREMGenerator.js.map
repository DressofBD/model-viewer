{"version":3,"file":"PMREMGenerator.js","sourceRoot":"","sources":["../../src/three-components/PMREMGenerator.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;AAEH,OAAO,EAAC,iBAAiB,EAAE,UAAU,EAAE,uBAAuB,EAAE,UAAU,EAAY,IAAI,EAAE,aAAa,EAAE,UAAU,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,KAAK,EAAiB,iBAAiB,EAAE,qBAAqB,EAAC,MAAM,OAAO,CAAC;AAEhQ,OAAO,EAAC,SAAS,EAAE,iBAAiB,EAAE,YAAY,EAAE,OAAO,EAAC,MAAM,+BAA+B,CAAC;AAElG;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,aAAa,GACtB,CAAC,UAAiC,EAAE,QAAuB,EACrC,EAAE;IAClB,MAAM,EAAC,kBAAkB,EAAE,QAAQ,EAAE,MAAM,EAAC,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;IACjE,gEAAgE;IAChE,oEAAoE;IACpE,iEAAiE;IACjE,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,aAAa;QAC7D,QAAQ,CAAC,MAAM,CAAC;IAEpB,eAAe,CAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;IAChD,WAAW,CAAC,kBAAkB,EAAE,MAAM,EAAE,QAAQ,CAAC,CAAC;IAElD,QAAQ,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;QAC1B,MAAM,CAAC,OAAO,EAAE,CAAC;IACnB,CAAC,CAAC,CAAC;IACH,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACrB,IAAI,CAAC,QAAqB,CAAC,OAAO,EAAE,CAAC;QACtC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC,CAAC,CAAC;IAEH,OAAO,kBAAkB,CAAC;AAC5B,CAAC,CAAC;AAEV,MAAM,KAAK,GAAG,CAAC,UAAiC,EAAE,EAAE;IAClD,MAAM,MAAM,GAAG;QACb,MAAM,EAAE,UAAU,CAAC,OAAO,CAAC,MAAM;QACjC,SAAS,EAAE,aAAa;QACxB,SAAS,EAAE,aAAa;QACxB,IAAI,EAAE,UAAU,CAAC,OAAO,CAAC,IAAI;QAC7B,eAAe,EAAE,KAAK;QACtB,UAAU,EAAE,UAAU,CAAC,OAAO,CAAC,UAAU;QACzC,QAAQ,EAAE,UAAU,CAAC,OAAO,CAAC,QAAQ;KACtC,CAAC;IAEF,+DAA+D;IAC/D,MAAM,OAAO,GAAG,CAAC,CAAC;IAClB,yEAAyE;IACzE,YAAY;IAEZ,MAAM,QAAQ,GAAiC,EAAE,CAAC;IAClD,MAAM,MAAM,GAAgB,EAAE,CAAC;IAE/B,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,OAAO,EAAE,CAAC,EAAE,EAAE;QACjC,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/B,IAAI,MAAM,GAAG,UAAU,CAAC;QACxB,IAAI,CAAC,GAAG,OAAO,EAAE;YACf,MAAM,YAAY,GAAG,IAAI,qBAAqB,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;YACzE,YAAY,CAAC,OAAO,CAAC,IAAI,GAAG,qBAAqB,GAAG,CAAC,CAAC;YACtD,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAC5B,MAAM,GAAG,YAAY,CAAC;SACvB;QACD,eAAe,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;QACjD,MAAM,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC;KAC7B;IAED,MAAM,kBAAkB,GAAG,IAAI,iBAAiB,CAC5C,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC,EAC9B,CAAC,GAAG,OAAO,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,EAChD,MAAM,CAAC,CAAC;IACZ,kBAAkB,CAAC,OAAO,CAAC,IAAI,GAAG,0BAA0B,CAAC;IAC7D,kBAAkB,CAAC,OAAO,CAAC,OAAO,GAAG,uBAAuB,CAAC;IAE7D,OAAO,EAAC,kBAAkB,EAAE,QAAQ,EAAE,MAAM,EAAC,CAAC;AAChD,CAAC,CAAC;AAEF,MAAM,eAAe,GACjB,CAAC,MAAmB,EACnB,MAA6B,EAC7B,OAAe,EACf,MAAc,EAAE,EAAE;IACjB,MAAM,OAAO,GAAG,OAAO,GAAG,CAAC,CAAC;IAC5B,MAAM,SAAS,GAAG,GAAG,GAAG,OAAO,CAAC;IAChC,MAAM,KAAK,GAAG,IAAI,mBAAmB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC5C,MAAM,EAAE,GAAI,KAAK,CAAC,UAAU,CAAC,EAAE,CAAC,KAAuB,CAAC;IACxD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAClC,IAAI,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;YACf,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC;SACpB;aAAM,EAAG,OAAO;YACf,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;SACvB;KACF;IACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QAC1B,eAAe;QACf,MAAM,QAAQ,GAAG,IAAI,aAAa,EAAE,CAAC;QACrC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC;QAC9C,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC;QAChD,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK;YACjC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACvC,QAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK;YAClC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACvC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC;QAEtC,MAAM,SAAS,GAAG,IAAI,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QAE5C,SAAS,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;QACjD,SAAS,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,GAAG,MAAM,CAAC;QACjE,SAAS,CAAC,QAAqB,CAAC,IAAI,GAAG,UAAU,CAAC;QACnD,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;QACnC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KACxB;AACH,CAAC,CAAC;AAEN,MAAM,eAAe,GACjB,CAAC,UAAiC,EACjC,QAAsC,EACtC,QAAuB,EAAE,EAAE;IAC1B,MAAM,YAAY,GAAG,IAAI,YAAY,EAAE,CAAC;IACxC,MAAM,UAAU,GAAG,IAAI,UAAU,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;IAC/C,MAAM,WAAW,GAAG,IAAI,KAAK,EAAE,CAAC;IAChC,MAAM,OAAO,GAAG,IAAI,IAAI,CAAC,IAAI,iBAAiB,EAAE,EAAE,YAAY,CAAC,CAAC;IAC/D,OAAO,CAAC,QAAqB,CAAC,IAAI,GAAG,UAAU,CAAC;IACjD,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IAEzB,YAAY,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,GAAG,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC;IAC/D,YAAY,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,GAAG,UAAU,CAAC,OAAO,CAAC;IACxD,YAAY,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK;QACrC,SAAS,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IAC3C,UAAU,CAAC,YAAY,CAAC,OAAO,EAAE,CAAC;IAClC,KAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;QAC7C,UAAU,CAAC,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACtC,YAAY,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK;YACtC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC5C,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;QACzC,YAAY,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,GAAG,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QAChE,YAAY,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;QACzD,YAAY,CAAC,QAAQ,CAAC,aAAa,CAAC,KAAK;YACrC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;KAC7C;AACH,CAAC,CAAC;AAEN,MAAM,WAAW,GACb,CAAC,kBAAqC,EACrC,MAAmB,EACnB,QAAuB,EAAE,EAAE;IAC1B,MAAM,YAAY,GAAG,IAAI,KAAK,EAAE,CAAC;IACjC,MAAM,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACtB,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACzB,CAAC,CAAC,CAAC;IACH,MAAM,UAAU,GAAG,IAAI,kBAAkB,CACrC,CAAC,EAAE,kBAAkB,CAAC,KAAK,EAAE,CAAC,EAAE,kBAAkB,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAErE,QAAQ,CAAC,eAAe,CAAC,kBAAkB,CAAC,CAAC;IAC7C,QAAQ,CAAC,MAAM,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;AAC5C,CAAC,CAAC;AAEN,MAAM,YAAa,SAAQ,iBAAiB;IAC1C;QACE,KAAK,CAAC;YAEJ,QAAQ,EAAE;gBACR,SAAS,EAAE,EAAC,KAAK,EAAE,GAAG,EAAC;gBACvB,MAAM,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC;gBACrB,aAAa,EAAE,EAAC,KAAK,EAAE,CAAC,EAAC;gBACzB,cAAc,EAAE,EAAC,KAAK,EAAE,CAAC,EAAC;aAC3B;YAED,YAAY,EAAE;;;;;;;;;;;;;;CAcnB;YAEK,cAAc,EAAE;;;;;;;EAOpB,YAAY;EACZ,iBAAiB;EACjB,OAAO;;;;;;;;;;;;;;;;;CAiBR;YAEK,QAAQ,EAAE,UAAU;SAErB,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,GAAG,gBAAgB,CAAC;IAC/B,CAAC;CACF;AAED,MAAM,aAAc,SAAQ,iBAAiB;IAC3C;QACE,KAAK,CAAC;YAEJ,QAAQ,EAAE;gBACR,SAAS,EAAE,EAAC,KAAK,EAAE,GAAG,EAAC;gBACvB,MAAM,EAAE,EAAC,KAAK,EAAE,IAAI,EAAC;gBACrB,aAAa,EAAE,EAAC,KAAK,EAAE,CAAC,EAAC;gBACzB,cAAc,EAAE,EAAC,KAAK,EAAE,CAAC,EAAC;gBAC1B,SAAS,EAAE,EAAC,KAAK,EAAE,CAAC,EAAC;aACtB;YAED,YAAY,EAAE;;;;;;;;;;;;CAYnB;YAEK,cAAc,EAAE;;;;;;;EAOpB,iBAAiB;EACjB,OAAO;;;;;;;;;;;;;;;;;;;;;;;CAuBR;YAEK,QAAQ,EAAE,UAAU;SAErB,CAAC,CAAC;QAEH,IAAI,CAAC,IAAI,GAAG,mBAAmB,CAAC;IAClC,CAAC;CACF","sourcesContent":["/*\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BoxBufferGeometry, CubeCamera, CubeUVReflectionMapping, DoubleSide, Material, Mesh, NearestFilter, NoBlending, OrthographicCamera, PlaneBufferGeometry, RawShaderMaterial, Scene, WebGLRenderer, WebGLRenderTarget, WebGLRenderTargetCube} from 'three';\n\nimport {encodings, getDirectionChunk, getFaceChunk, texelIO} from './shader-chunk/common.glsl.js';\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE.\n */\nexport const generatePMREM =\n    (cubeTarget: WebGLRenderTargetCube, renderer: WebGLRenderer):\n        WebGLRenderTarget => {\n          const {cubeUVRenderTarget, cubeLods, meshes} = setup(cubeTarget);\n          // This hack is necessary for now because CubeUV is not really a\n          // first-class citizen within the Standard material yet, and it does\n          // not seem to be easy to add new uniforms to existing materials.\n          renderer.properties.get(cubeUVRenderTarget.texture).__maxMipLevel =\n              cubeLods.length;\n\n          generateMipmaps(cubeTarget, cubeLods, renderer);\n          packMipmaps(cubeUVRenderTarget, meshes, renderer);\n\n          cubeLods.forEach((target) => {\n            target.dispose();\n          });\n          meshes.forEach((mesh) => {\n            (mesh.material as Material).dispose();\n            mesh.geometry.dispose();\n          });\n\n          return cubeUVRenderTarget;\n        };\n\nconst setup = (cubeTarget: WebGLRenderTargetCube) => {\n  const params = {\n    format: cubeTarget.texture.format,\n    magFilter: NearestFilter,\n    minFilter: NearestFilter,\n    type: cubeTarget.texture.type,\n    generateMipmaps: false,\n    anisotropy: cubeTarget.texture.anisotropy,\n    encoding: cubeTarget.texture.encoding\n  };\n\n  // Hard-coded to max faceSize = 256 until we can add a uniform.\n  const maxLods = 8;\n  // Math.log(cubeTarget.width) / Math.log(2) - 2;  // IE11 doesn't support\n  // Math.log2\n\n  const cubeLods: Array<WebGLRenderTargetCube> = [];\n  const meshes: Array<Mesh> = [];\n\n  let offset = 0;\n  for (let i = 0; i <= maxLods; i++) {\n    const sizeLod = Math.pow(2, i);\n    let target = cubeTarget;\n    if (i < maxLods) {\n      const renderTarget = new WebGLRenderTargetCube(sizeLod, sizeLod, params);\n      renderTarget.texture.name = 'PMREMGenerator.cube' + i;\n      cubeLods.push(renderTarget);\n      target = renderTarget;\n    }\n    appendLodMeshes(meshes, target, sizeLod, offset);\n    offset += 2 * (sizeLod + 2);\n  }\n\n  const cubeUVRenderTarget = new WebGLRenderTarget(\n      3 * (Math.pow(2, maxLods) + 2),\n      4 * maxLods + 2 * (Math.pow(2, maxLods + 1) - 1),\n      params);\n  cubeUVRenderTarget.texture.name = 'PMREMCubeUVPacker.cubeUv';\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\n  return {cubeUVRenderTarget, cubeLods, meshes};\n};\n\nconst appendLodMeshes =\n    (meshes: Array<Mesh>,\n     target: WebGLRenderTargetCube,\n     sizeLod: number,\n     offset: number) => {\n      const sizePad = sizeLod + 2;\n      const texelSize = 1.0 / sizeLod;\n      const plane = new PlaneBufferGeometry(1, 1);\n      const uv = (plane.attributes.uv.array as Array<number>);\n      for (let i = 0; i < uv.length; i++) {\n        if (uv[i] === 0) {\n          uv[i] = -texelSize;\n        } else {  // == 1\n          uv[i] = 1 + texelSize;\n        }\n      }\n      for (let i = 0; i < 6; i++) {\n        // 6 Cube Faces\n        const material = new PackingShader();\n        material.uniforms.texelSize.value = texelSize;\n        material.uniforms.envMap.value = target.texture;\n        material.uniforms.inputEncoding.value =\n            encodings[target.texture.encoding];\n        material.uniforms.outputEncoding.value =\n            encodings[target.texture.encoding];\n        material.uniforms.faceIndex.value = i;\n\n        const planeMesh = new Mesh(plane, material);\n\n        planeMesh.position.x = (0.5 + (i % 3)) * sizePad;\n        planeMesh.position.y = (0.5 + (i > 2 ? 1 : 0)) * sizePad + offset;\n        (planeMesh.material as Material).side = DoubleSide;\n        planeMesh.scale.setScalar(sizePad);\n        meshes.push(planeMesh);\n      }\n    };\n\nconst generateMipmaps =\n    (cubeTarget: WebGLRenderTargetCube,\n     cubeLods: Array<WebGLRenderTargetCube>,\n     renderer: WebGLRenderer) => {\n      const mipmapShader = new MipmapShader();\n      const cubeCamera = new CubeCamera(0.1, 100, 1);\n      const mipmapScene = new Scene();\n      const boxMesh = new Mesh(new BoxBufferGeometry(), mipmapShader);\n      (boxMesh.material as Material).side = DoubleSide;\n      mipmapScene.add(boxMesh);\n\n      mipmapShader.uniforms.texelSize.value = 1.0 / cubeTarget.width;\n      mipmapShader.uniforms.envMap.value = cubeTarget.texture;\n      mipmapShader.uniforms.inputEncoding.value =\n          encodings[cubeTarget.texture.encoding];\n      cubeCamera.renderTarget.dispose();\n      for (let i = cubeLods.length - 1; i >= 0; i--) {\n        cubeCamera.renderTarget = cubeLods[i];\n        mipmapShader.uniforms.outputEncoding.value =\n            encodings[cubeLods[i].texture.encoding];\n        cubeCamera.update(renderer, mipmapScene);\n        mipmapShader.uniforms.texelSize.value = 1.0 / cubeLods[i].width;\n        mipmapShader.uniforms.envMap.value = cubeLods[i].texture;\n        mipmapShader.uniforms.inputEncoding.value =\n            encodings[cubeLods[i].texture.encoding];\n      }\n    };\n\nconst packMipmaps =\n    (cubeUVRenderTarget: WebGLRenderTarget,\n     meshes: Array<Mesh>,\n     renderer: WebGLRenderer) => {\n      const packingScene = new Scene();\n      meshes.forEach((mesh) => {\n        packingScene.add(mesh);\n      });\n      const flatCamera = new OrthographicCamera(\n          0, cubeUVRenderTarget.width, 0, cubeUVRenderTarget.height, 0, 1);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n      renderer.render(packingScene, flatCamera);\n    };\n\nclass MipmapShader extends RawShaderMaterial {\n  constructor() {\n    super({\n\n      uniforms: {\n        texelSize: {value: 0.5},\n        envMap: {value: null},\n        inputEncoding: {value: 2},\n        outputEncoding: {value: 2},\n      },\n\n      vertexShader: `\nprecision mediump float;\nprecision mediump int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvoid main() {\n    vUv = uv;\n    vPosition = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`,\n\n      fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform float texelSize;\nuniform samplerCube envMap;\n${getFaceChunk}\n${getDirectionChunk}\n${texelIO}\nvoid main() {\n  int face = getFace(vPosition);\n  vec2 uv = vUv - 0.5 * texelSize;\n  vec3 texelDir = getDirection(uv, face);\n  vec3 color = inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  uv.x += texelSize;\n  texelDir = getDirection(uv, face);\n  color += inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  uv.y += texelSize;\n  texelDir = getDirection(uv, face);\n  color += inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  uv.x -= texelSize;\n  texelDir = getDirection(uv, face);\n  color += inputTexelToLinear(textureCube(envMap, texelDir)).rgb;\n  gl_FragColor = linearToOutputTexel(vec4(color * 0.25, 1.0));\n}\n`,\n\n      blending: NoBlending\n\n    });\n\n    this.type = 'PMREMGenerator';\n  }\n}\n\nclass PackingShader extends RawShaderMaterial {\n  constructor() {\n    super({\n\n      uniforms: {\n        texelSize: {value: 0.5},\n        envMap: {value: null},\n        inputEncoding: {value: 2},\n        outputEncoding: {value: 2},\n        faceIndex: {value: 0},\n      },\n\n      vertexShader: `\nprecision mediump float;\nprecision mediump int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`,\n\n      fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform float texelSize;\nuniform samplerCube envMap;\nuniform int faceIndex;\n${getDirectionChunk}\n${texelIO}\nvoid main() {\n    if ((vUv.x >= 0.0 && vUv.x <= 1.0) || (vUv.y >= 0.0 && vUv.y <= 1.0)) {\n      // By using UV coordinates that go past [0, 1], textureCube automatically \n      // grabs our neighboring face values for our padded edge.\n      vec3 direction = getDirection(vUv, faceIndex);\n      gl_FragColor = textureCube(envMap, direction);\n    } else {\n      // The corner pixels do not represent any one face, so to get consistent \n      // interpolation, they must average the three neighboring face corners.\n      vec2 uv = vUv;\n      uv.x += vUv.x < 0.0 ? texelSize : -texelSize;\n      vec3 direction = getDirection(uv, faceIndex);\n      vec3 color = inputTexelToLinear(textureCube(envMap, direction)).rgb;\n      uv.y += vUv.y < 0.0 ? texelSize : -texelSize;\n      direction = getDirection(uv, faceIndex);\n      color += inputTexelToLinear(textureCube(envMap, direction)).rgb;\n      uv.x = vUv.x;\n      direction = getDirection(uv, faceIndex);\n      color += inputTexelToLinear(textureCube(envMap, direction)).rgb;\n      gl_FragColor = linearToOutputTexel(vec4(color / 3.0, 1.0));\n    }\n}\n`,\n\n      blending: NoBlending\n\n    });\n\n    this.type = 'PMREMCubeUVPacker';\n  }\n}\n"]}